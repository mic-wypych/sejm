---
title: "sejm_members"
output: quarto::html_vignette
vignette: >
  %\VignetteIndexEntry{sejm_members}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(sejm)
library(tidyr)
library(dplyr)
library(ggplot2)
library(plotly)
library(reactable)
library(stringr)
library(glue)
```


## Members of sejm with basic info

- get data on mps
- wrangle into proper shape
- plot with hover
- add logic to display info on click

```{r}
devtools::load_all()
df_mps <- get_mps()

members_by_party <- df_mps %>%
        group_by(club) %>%
        arrange(lastName) %>%
        mutate(party_size = n()) %>%
        ungroup()
      
      # Order parties by size (optional)
      party_order <- members_by_party %>%
        group_by(club) %>%
        summarize(count = n()) %>%
        arrange(desc(count)) %>%
        pull(club)
      
      members_by_party$club <- factor(members_by_party$club, levels = rev(c("Razem", "Lewica", "Polska2050-TD", "PSL-TD", "KO", "PiS", "Republikanie", "Konfederacja", "niez.")))
      members_arranged <- members_by_party %>% arrange(club, lastName) %>% ungroup()
      
      # Calculate positions for hemicycle layout
      # Start with the largest radius (outer edge)
      base_radius <- 10
      # Number of rows in the hemicycle
      num_rows <- 5
      # Calculate radius for each row (decreasing as we move inward)
      radii <- seq(base_radius, base_radius * 0.6, length.out = num_rows)
      
      # Calculate positions for each MP
      n <- nrow(members_arranged)
      
      # Function to assign positions in hemicycle
      create_hemicycle_coords <- function(df) {
        # Define the hemicycle angle range (pi radians = 180 degrees)
        angle_range <- pi
        
        # Get unique parties and their sizes
        party_sizes <- df %>%
          group_by(club) %>%
          summarize(size = n()) %>%
          arrange(club)
        
        # Allocate angles proportionally to party sizes
        total_mps <- sum(party_sizes$size)
        party_angles <- party_sizes %>%
          mutate(
            angle_start = c(0, cumsum(head(size / total_mps * angle_range, -1))),
            angle_end = cumsum(size / total_mps * angle_range)
          )
        
        # Create result dataframe
        result <- data.frame()
        
        # For each party, create points in the hemicycle
        for (i in 1:nrow(party_sizes)) {
          party_df <- df %>% filter(club == party_sizes$club[i])
          party_size <- nrow(party_df)
          
          # Get angle range for this party
          start_angle <- party_angles$angle_start[i]
          end_angle <- party_angles$angle_end[i]
          
          # Distribute MPs across rows
          mps_per_row <- ceiling(party_size / num_rows)
          
          # Create positions for each MP in this party
          party_positions <- data.frame()
          mp_count <- 0
          
          for (row in 1:num_rows) {
            row_radius <- radii[row]
            row_mps <- min(mps_per_row, party_size - mp_count)
            
            if (row_mps <= 0) break
            
            # Calculate angles for this row
            if (row_mps == 1) {
              row_angles <- (start_angle + end_angle) / 2
            } else {
              row_angles <- seq(start_angle, end_angle, length.out = row_mps)
            }
            
            # Calculate coordinates
            x_coords <- row_radius * cos(row_angles)
            y_coords <- row_radius * sin(row_angles)
            
            # Add to positions dataframe
            row_positions <- data.frame(
              x = x_coords,
              y = y_coords,
              row = row
            )
            
            party_positions <- rbind(party_positions, row_positions)
            mp_count <- mp_count + row_mps
            
            if (mp_count >= party_size) break
          }
          
          # Ensure we have the correct number of positions
          party_positions <- party_positions[1:party_size, ]
          
          # Add to party dataframe
          party_df$x <- party_positions$x
          party_df$y <- party_positions$y
          party_df$row <- party_positions$row
          
          # Add to result
          result <- rbind(result, party_df)
        }
        result <- result %>% arrange(club, lastName)

        return(result)
      }
      
      # Apply the function to create coordinates
      plotData <- create_hemicycle_coords(members_arranged)
      
      # Adjust y-coordinates to make sure all points are in the upper half-plane
      plotData$y[plotData$y < 0] <- 0.1
      

      plotData$row <- row.names(plotData)

      # Create the plot
      p <- ggplot(plotData, aes(x = x, y = y, color = club, key = rownames(plotData),
                                 text = paste0("<b>", firstName, " ", lastName, "</b><br>",
                                              "Party: ", club))) +
        geom_point(size = 4, alpha = 0.8) +
        scale_color_manual(values = c("PiS" = "#012b7f", "KO" = "#d41c3c", "PSL-TD" = "#3cb43c",
        "Polska2050-TD" = "#f9c300", "Lewica" = "#a81849", "Razem" = "#870f57",
        "Konfederacja" = "#1b263f", "Republikanie" = "#749cbc", "niez." = "#000000")) +
        theme_void() +
        theme(legend.title = element_text(size = 10),
              legend.text = element_text(size = 8),
              legend.position = "bottom",
              plot.margin = unit(c(1, 1, 1, 1), "cm")) +
        labs(color = "Party") +
        coord_fixed(ratio = 1) +

        # Set limits to ensure we see the proper hemicycle shape
        xlim(c(-base_radius-1, base_radius+1)) +
        ylim(c(base_radius+1, -1))
      
      ggplotly(p, tooltip = "text") |>
        layout(hoverlabel = list(bgcolor = "white", 
                                bordercolor = "black", 
                                font = list(family = "Arial", size = 12)),
               legend = list(orientation = "h", y = -0.1))
```

## Table with MP activity

- get data on mps
- get data on interpellations
- get data on questions
- get data on votes?
- get data on photos?
- make it in reactable table

Get data:
```{r}
devtools::load_all()


df_int <- get_interpellations() |> 
  unnest(from) |> 
  count(from, name = "inter_count") |>
        mutate(from = as.integer(from))
df_q <- get_questions() |> 
  unnest(from) |> 
  count(from, name = "q_count") |>
  mutate(from = as.integer(from))

df_mps <- df_mps %>%
        left_join(df_q, by = c("id" = "from")) |>
        left_join(df_int, by = c("id" = "from")) |>
        mutate(q_count = replace_na(q_count, 0),
               inter_count = replace_na(inter_count, 0))
```


make the table:


```{r}
bar_chart <- function(label, width = "100%", height = "1rem", fill = "#00bfc4", background = NULL) {
        bar <- div(style = list(background = fill, width = width, height = height, transition = "width 0.6s ease"))
        chart <- div(style = list(flexGrow = 1, marginLeft = "0.5rem", background = background), bar)
        div(style = list(display = "flex", alignItems = "center"), label, chart)
      }

df_mps |>
        mutate(photo = paste0("https://api.sejm.gov.pl/sejm/term10/MP/", id, "/photo")) %>%
        select(firstLastName, photo, club, birthDate, districtName, numberOfVotes, q_count, inter_count) |>
        reactable(
          columns = list(
            numberOfVotes = colDef(name = "number of votes", align = "left", cell = function(value) {
              width <- paste0(value / max(df_mps$numberOfVotes) * 100, "%")
              bar_chart(value, width = width)
            }),
            photo = colDef(cell = function(value) {
              image <- img(src = sprintf(value), style = "height: 50px; border-radius: 20%;")
              tagList(
                div(style = "display: inline-block; width: 45px;", image)
              )
            }),
            q_count = colDef(name = "number of questions", align = "left", cell = function(value) {
              width <- paste0(value / max(df_mps$q_count) * 100, "%")
              bar_chart(value, width = width, fill = "#2a9d8f")
            }),
            inter_count = colDef(name = "number of interpellations", align = "left", cell = function(value) {
              width <- paste0(value / max(df_mps$inter_count) * 100, "%")
              bar_chart(value, width = width, fill = "#8338ec")
            })
          ))

```